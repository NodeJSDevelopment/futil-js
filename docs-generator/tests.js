module.exports = {
  "map arrays": "f.map(x => x * x, [1, 2, 3])\n/* => [1, 4, 9] */\n",
  "map plain objects": "f.map(x => x * x, { a: 1, b: 2, c: 3 })\n/* => {\n      a: 1,\n      b: 4,\n      c: 9,\n    } */\n",
  "deepMap arrays": "const arr = [0, [1, [2, []]]]\n\nconst arrBackup = _.cloneDeep(arr)\n\nconst arrMutated = f.deepMap(e => e.concat(101), arr)\n\n// Checking immutability\narr\n/* => arrBackup */\n\narrMutated\n/* => [0, [1, [2, [101], 101], 101]] */\n",
  "deepMap plain objects": "const obj = {\n  a: {\n    match: {\n      id: 1\n    },\n    b: {\n      match: {\n        id: 2\n      },\n      c: {\n        match: {\n          id: 3\n        }\n      }\n    }\n  }\n}\n\nconst objBackup = _.cloneDeep(obj)\n\nconst path = 'match.matched'\nconst setMatched = e => e.match && _.set(path, true, e)\nconst objMutated = f.deepMap(e => setMatched(e) || e)(obj)\n\n// Checking immutability\nobj\n/* => objBackup */\n\nobjMutated\n/* => {\n      a: {\n        match: {\n          id: 1,\n          matched: true,\n        },\n        b: {\n          match: {\n            id: 2,\n            matched: true,\n          },\n          c: {\n            match: {\n              id: 3,\n              matched: true,\n            },\n          },\n        },\n      },\n    } */\n",
  "deepMap plain objects with arrays with objects": "const obj = {\n  a: {\n    array: [0, [1, [2, [{ match: { id: 0 } }]]]],\n    match: {\n      id: 1\n    },\n    b: {\n      match: {\n        id: 2\n      },\n      c: {\n        match: {\n          id: 3\n        }\n      }\n    }\n  }\n}\n\nconst objBackup = _.cloneDeep(obj)\n\nconst path = 'match.matched'\nconst setMatched = e => e.match && _.set(path, true, e)\nconst push101 = e => _.isArray(e) && e.concat(101)\nconst objMutated = f.deepMap(e => push101(e) || setMatched(e) || e)(obj)\n\n// Checking immutability\nobj\n/* => objBackup */\n\nobjMutated\n/* => {\n      a: {\n        array: [\n          0,\n          [1, [2, [{ match: { id: 0, matched: true } }, 101], 101], 101],\n          101,\n        ],\n        match: {\n          id: 1,\n          matched: true,\n        },\n        b: {\n          match: {\n            id: 2,\n            matched: true,\n          },\n          c: {\n            match: {\n              id: 3,\n              matched: true,\n            },\n          },\n        },\n      },\n    } */\n",
  "compactJoin": "F.compactJoin(',', [1, undefined, 2, null, 3])\n/* => '1,2,3' */\nF.compactJoin(' and ', [null, 'Alice', 'Bob', false])\n/* => \n      'Alice and Bob'\n     */\n",
  "dotJoin": "F.dotJoin([1, undefined, 2, null, 3])\n/* => '1.2.3' */\nF.dotJoin([null, 'Alice', 'Bob', false])\n/* => 'Alice.Bob' */\n",
  "repeated": "F.repeated([1, 1, 2, 3, 3, 4])\n/* => [1, 3] */\nF.repeated(['a', 'b', 'b'])\n/* => ['b'] */\n",
  "mergeRanges": "F.mergeRanges([\n  [0, 2],\n  [1, 4]\n])\n/* => [[0, 4]] */\nF.mergeRanges([null, [1, 4]])\n/* => [[1, 4]] */\nF.mergeRanges([\n  [0, 1],\n  [1, 4],\n  [2, 4],\n  [3, 5]\n])\n/* => [\n      [0, 5],\n    ] */\n",
  "cycle": "let cycle = F.cycle([1, 2, 3])\ncycle(1)\n/* => 2 */\ncycle(2)\n/* => 3 */\ncycle(3)\n/* => 1 */\ncycle(4)\n/* => 1 */\n\ncycle = F.cycle([true, false])\ncycle(true)\n/* => false */\ncycle(false)\n/* => true */\ncycle(null)\n/* => true */\n\nF.cycle([true, false], true)\n/* => false */\n",
  "arrayToObject": "F.arrayToObject(\n  x => `key${x}`,\n  x => `val${x}`,\n  ['a', 'b', 'c']\n)\n\n/* => { keya: 'vala', keyb: 'valb', keyc: 'valc' } */\n",
  "pushIn": "let fn = F.pushIn([1, 2, 3])\nfn(4)\n/* => [1, 2, 3, 4] */\n",
  "pushOn": "let arr = [1, 2, 3]\nlet fn = F.pushOn(arr)\nfn(4)\n/* => [1, 2, 3, 4] */\narr\n/* => [1, 2, 3, 4] */\n",
  "moveIndex": "let arr = [1, 2, 3]\nlet x = F.moveIndex(1, 0, arr)\nx\n/* => [2, 1, 3] */\narr\n/* => [1, 2, 3] */\n",
  "zipObjectDeepWith": "F.zipObjectDeepWith(['a', 'b'], () => 1)\n/* => {\n      a: 1,\n      b: 1,\n    } */\n",
  "flags": "F.flags(['a', 'b', 'c'])\n/* => {\n      a: true,\n      b: true,\n      c: true,\n    } */\n",
  "prefixes": "F.prefixes(['root', 'criteria', 'someNode'])\n/* => [\n      ['root'],\n      ['root', 'criteria'],\n      ['root', 'criteria', 'someNode'],\n    ] */\nF.prefixes('abc')\n/* => [\n      ['a'],\n      ['a', 'b'],\n      ['a', 'b', 'c'],\n    ] */\n",
  "encoder": "let encoder = F.encoder('->')\nencoder.encode(['a', 'b'])\n/* => 'a->b' */\nencoder.decode('a->b')\n/* => ['a', 'b'] */\n",
  "dotEncoder": "F.dotEncoder.encode(['a', 'b'])\n/* => 'a.b' */\nF.dotEncoder.decode('a.b')\n/* => ['a', 'b'] */\n",
  "slashEncoder": "F.slashEncoder.encode(['a', 'b'])\n/* => 'a/b' */\nF.slashEncoder.decode('a/b')\n/* => ['a', 'b'] */\n",
  "chunkBy": "F.chunkBy(([a], b) => b % a === 0, [2, 2, 2, 3, 2, 2])\n\n/* => [[2, 2, 2], [3], [2, 2]] */\n\nF.chunkBy(([x], y) => (x * y) % 3 === 0)([1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n/* => [[1], [2, 3], [4], [5, 6], [7], [8, 9]] */\n",
  "toggleElement": "F.toggleElement('b', ['a', 'b', 'c', 'd'])\n/* => [\n      'a',\n      'c',\n      'd',\n    ] */\nF.toggleElement('b', ['a', 'c', 'd'])\n/* => [\n      'a',\n      'c',\n      'd',\n      'b',\n    ] */\n",
  "toggleElementBy": "let list = ['a', 'b', 'c']\nlet valueToToggle = 'b'\n\nlet toggleB = shouldAdd => F.toggleElementBy(!shouldAdd, valueToToggle, list)\n\ntoggleB(true)\n/* => ['a', 'b', 'c', 'b'] */\ntoggleB(false)\n/* => ['a', 'c'] */\n",
  "intersperse": "F.intersperse((acc, i, xs) => (i === xs.length - 1 ? 'and finally' : 'and'), [\n  1,\n  2,\n  3\n])\n\n/* => [1, 'and', 2, 'and finally', 3] */\nF.intersperse('and', [1, 2, 3])\n/* => [\n      1,\n      'and',\n      2,\n      'and',\n      3,\n    ] */\n",
  "replaceElementBy": "F.replaceElementBy(c => c > 10, 0, [1, 11, 3, 5])\n/* => [\n      1,\n      0,\n      3,\n      5,\n    ] */\n",
  "replaceElement": "F.replaceElement(11, 0, [1, 11, 3, 5])\n/* => [1, 0, 3, 5] */\n",
  "combine aspect states": "let f = Command(() => 6)\nf.state.status\n/* => null */\nf.state.processing\n/* => false */\nf.state.failed\n/* => false */\nf.state.succeeded\n/* => false */\nf.state.logs\n/* => [] */\nf.state.errors\n/* => [] */\n",
  "support .after calls (`logs` aspect)": "let f = Command(() => 6)\nawait f()\nf.state.logs\n/* => [6] */\nawait f()\nf.state.logs\n/* => [6, 6] */\n",
  "support .onError and before (`concurrency`, `errors`, and `status` aspects)": "let g = Command(() => {\n  throw Error(5)\n})\ng.state.processing\n/* => false */\nawait g()\ng.state.errors[0].message\n/* => '5' */\ng.state.processing\n/* => false */\n// Should be blocked as a concurrent run since it's still processing\ng.state.processing = true\nawait g()\ng.state.errors[1].message\n/* => 'Concurrent Runs Not Allowed' */\n",
  "support throwing in onError": "// Use the single error object to avoid 'Unhandled promise rejection' in\n// some browsers.\nlet theException = new Error('hi from aspect')\nlet ThrowHi = aspect({\n  onError() {\n    throw theException\n  }\n})\nlet throwsHi = ThrowHi(() => {\n  throw Error('Not hi')\n})\n\nthrowsHi()\n/* => throws theException */\n",
  "support single error": "let throwsHi = aspects.error()(() => {\n  throw Error('Hi')\n})\nawait throwsHi()\nthrowsHi.state.error.message\n/* => 'Hi' */\n",
  "support status and clearing status": "// Increase the timeout/delay to hundreds ms to make testing IE9/10/11 more\n// stable & avoid exception:\n// AssertionError: expected null to equal 'processing'\nlet clearingStatus = aspects.command(undefined, 250)\nlet f = clearingStatus(async () => Promise.delay(200))\nlet result = f()\nawait Promise.delay(100)\nf.state.status\n/* => 'processing' */\nf.state.processing\n/* => true */\nawait result\nf.state.status\n/* => 'succeeded' */\nf.state.succeeded\n/* => true */\nawait Promise.delay(300)\nf.state.status\n/* => null */\nlet g = clearingStatus(async () => {\n  throw Error('error')\n})\nawait g()\ng.state.status\n/* => 'failed' */\ng.state.failed\n/* => true */\nawait Promise.delay(15)\nf.state.status\n/* => null */\n",
  "support synchronous aspects": "let x = 1\nlet y = 0\nlet firstIncrementX = aspectSync({\n  before() {\n    x++\n  }\n})\nlet f = firstIncrementX(() => {\n  y = x\n})\nf()\ny\n/* => 2 */\n",
  "flowMap": "F.flowMap(\n  n => n + n,\n  n => n * n\n)([0, 1, 2, 3, 4])\n/* => [\n      0,\n      4,\n      16,\n      36,\n      64,\n    ] */\n\nF.flowMap(\n  s => s.toUpperCase(),\n  s => s.split(''),\n  s => s.reverse(),\n  s => s.join('')\n)(['Smart', 'Procure'])\n\n/* => ['TRAMS', 'ERUCORP'] */\n",
  "findApply": "let x = {\n  a: 1\n}\nF.findApply(f => x[f], ['b', 'c', 'a'])\n/* => 1 */\nF.findApply(f => x[f], ['b', 'c'])\n/* => undefined */\nlet xs = [{ b: 2 }, { c: 3 }, { a: 1 }]\nF.findApply(f => f.a, xs)\n/* => 1 */\nF.findApply('a', xs)\n/* => 1 */\nF.findApply('d', xs)\n/* => undefined */\n",
  "insertAtIndex": "let arr = [1, 2, 3]\nlet x = F.insertAtIndex(1, 5, arr)\nx\n/* => [1, 5, 2, 3] */\narr\n/* => [1, 2, 3] */\n\nF.insertAtIndex(1, 'z', 'abc')\n/* => 'azbc' */\n\nvar result = F.insertAtIndex(0, '<span>', 'pretty please')\nresult\n/* => '<span>pretty please' */\n",
  "compactMap": "let names = ['adam', 'betty', 'carlos', 'doug', 'emily']\nlet exceptDoug = fn => x => (x === 'doug' ? undefined : fn(x))\nF.compactMap(_.capitalize, names)\n/* => [\n      'Adam',\n      'Betty',\n      'Carlos',\n      'Doug',\n      'Emily',\n    ] */\nF.compactMap(exceptDoug(_.capitalize), names)\n/* => [\n      'Adam',\n      'Betty',\n      'Carlos',\n      'Emily',\n    ] */\nF.compactMap(x => x - 2, [0, 1, 2, 3])\n/* => [-2, -1, 1] */\n",
  "getIn": "f.getIn(hero, 'name')\n/* => hero.name */\nconst obj = { a: 1 }\nf.inversions.getIn(obj)('a')\n/* => 1 */\nf.getIn(obj)('a')\n/* => 1 */\n",
  "defaultsOn": "let clone = _.clone(hero)\nlet defaultsResult = _.defaults({ consort: 'Auge' }, clone)\nf.defaultsOn(clone, { consort: 'Auge' })\n/* => defaultsResult */\n\nf.defaultsOn(\n  {\n    a: 2,\n    b: 3,\n    c: 4\n  },\n  {\n    a: 1\n  }\n)\n\n/* => {\n        a: 1,\n        b: 3,\n        c: 4,\n      } */\n",
  "debounceAsync": "let inner = sinon.spy(x => x + 10)\nlet fn = F.debounceAsync(10, inner)\nlet result = await Promise.all([fn(1), fn(2), fn(3)])\ninner\n/* => to have been called 1 times */\nresult\n/* => [13, 13, 13] */\nlet secondResult = await Promise.all([fn(11), fn(12), fn(13)])\nsecondResult\n/* => [23, 23, 23] */\n",
  "demonstrate failing with regular debounce": "let inner = sinon.spy(x => x + 10)\nlet fn = _.debounce(10, inner)\nlet result = await Promise.all([fn(1), fn(2), fn(3)])\ninner\n/* => to have been called 0 times */\nresult\n/* => [undefined, undefined, undefined] */\nlet secondResult = await Promise.all([fn(11), fn(12), fn(13)])\nsecondResult\n/* => [undefined, undefined, undefined] */\n",
  "flurry": "let add = (x, y) => x + y\nlet double = x => x * 2\n\n// Passing all args\nF.flurry(add, double)(1, 4)\n/* => 10 */\n// Passing 1 at a time\nF.flurry(add, double)(1)(4)\n/* => 10 */\n",
  "differentLast": "F.mapIndexed(F.differentLast('a', 'b'), [\n  { a: 1, b: 2 },\n  { a: 1, b: 2 },\n  { a: 1, b: 2 }\n])\n\n/* => [1, 1, 2] */\n",
  "throws": "f.throws(Error('oops'))\n/* => throws exception */\n",
  "isNotNil": "f.isNotNil(null)\n/* => false */\nf.isNotNil(undefined)\n/* => false */\nf.isNotNil(0)\n/* => true */\nf.isNotNil('')\n/* => true */\nf.isNotNil([])\n/* => true */\n",
  "exists": "f.exists\n/* => f.isNotNil */\n",
  "isMultiple": "f.isMultiple([''])\n/* => false */\nf.isMultiple(['', ''])\n/* => true */\nf.isMultiple('a')\n/* => false */\nf.isMultiple('asdf')\n/* => true */\nf.isMultiple({ x: 1, y: 2 })\n/* => false */\nf.isMultiple({ x: 1, y: 2, length: 2 })\n/* => true */\n",
  "append": "f.append('a', 'b')\n/* => 'ba' */\nf.append(1, 4)\n/* => 5 */\n",
  "isBlank": "f.isBlank(1)\n/* => false */\nf.isBlank('asdf')\n/* => false */\nf.isBlank({ a: 1 })\n/* => false */\nf.isBlank([3, 4])\n/* => false */\nf.isBlank(new Date())\n/* => false */\n\nf.isBlank({\n  a: 1,\n  b: 'as'\n})\n\n/* => false */\nf.isBlank(null)\n/* => true */\nf.isBlank(undefined)\n/* => true */\nf.isBlank('')\n/* => true */\nf.isBlank([])\n/* => true */\nf.isBlank({})\n/* => true */\n",
  "isBlankDeep": "f.isBlankDeep(_.every)(1)\n/* => false */\nf.isBlankDeep(_.every)(false)\n/* => false */\nf.isBlankDeep(_.every)('')\n/* => true */\n\nf.isBlankDeep(_.every)({\n  a: 1,\n  b: 'as'\n})\n\n/* => false */\n\nf.isBlankDeep(_.every)({\n  a: null,\n  b: '',\n  c: [],\n  d: {\n    b: ''\n  }\n})\n\n/* => true */\n",
  "functionLens": "let l = F.functionLens(1)\nl()\n/* => 1 */\nl(5)\nl()\n/* => 5 */\n",
  "objectLens": "let l = F.objectLens(1)\nl.get()\n/* => 1 */\nl.set(5)\nl.get()\n/* => 5 */\n",
  "fnToObj": "let l = F.fnToObj(F.functionLens(1))\nl.get()\n/* => 1 */\nl.set(5)\nl.get()\n/* => 5 */\n",
  "objToFn": "let l = F.objToFn(F.objectLens(1))\nl()\n/* => 1 */\nl(5)\nl()\n/* => 5 */\n",
  "lensProp": "let l = F.lensProp('x', {\n  x: 1\n})\nl.get()\n/* => 1 */\nl.set(5)\nl.get()\n/* => 5 */\n",
  "lensProp deep": "let l = F.lensProp('x.a', {\n  x: {\n    a: 1\n  }\n})\nl.get()\n/* => 1 */\nl.set(5)\nl.get()\n/* => 5 */\n",
  "lensOf": "let l = F.lensOf({\n  a: 1\n})\nl.a.get()\n/* => 1 */\nl.a.set(5)\nl.a.get()\n/* => 5 */\n",
  "includeLens": "let object = {\n  arr: ['a', 'b', 'c', 'd']\n}\nlet includesB = F.includeLens('b', 'arr', object)\nF.view(includesB)\n/* => true */\nF.off(includesB)()\nF.view(includesB)\n/* => false */\nobject.arr\n/* => ['a', 'c', 'd'] */\nF.on(includesB)()\nF.view(includesB)\n/* => true */\nobject.arr\n/* => ['a', 'c', 'd', 'b'] */\n// Subsequent calls don't result in multiple `b`s because of _.uniq\nF.on(includesB)()\nF.view(includesB)\n/* => true */\nobject.arr\n/* => ['a', 'c', 'd', 'b'] */\n",
  "view": "let x = {\n  a: 1,\n  b: 2\n}\nF.view('a', x)\n/* => 1 */\n",
  "views": "let x = {\n  a: 1,\n  b: 2\n}\nF.views('a', x)()\n/* => 1 */\n",
  "set": "let x = {\n  a: 1,\n  b: 2\n}\nF.set(5, 'a', x)\nx.a\n/* => 5 */\n",
  "sets": "let x = {\n  a: 1,\n  b: 2\n}\nF.sets(5, 'a', x)()\nx.a\n/* => 5 */\n",
  "setsWith": "let object = {\n  a: 1\n}\nlet setter = F.setsWith(x => x * 2, 'a', object)\nsetter(5)\nobject.a\n/* => 10 */\n",
  "flip": "let object = {\n  a: 1\n}\nF.flip('a', object)()\nobject.a\n/* => false */\n",
  "on": "let object = {\n  a: 1\n}\nF.on('a', object)()\nobject.a\n/* => true */\n",
  "off": "let object = {\n  a: 1\n}\nF.off('a', object)()\nobject.a\n/* => false */\n",
  "arrayLens": "let arrayLens = val => {\n  let result = [val]\n  result.push(x => {\n    result[0] = x\n  })\n  return result\n}\nlet lens = arrayLens(false)\nF.on(lens)()\nlens[0]\n/* => true */\nF.off(lens)()\nlens[0]\n/* => false */\nF.flip(lens)()\nlens[0]\n/* => true */\n",
  "functionPairLens": "let object = {\n  a: false\n}\nlet get = () => object.a\nlet set = x => {\n  object.a = x\n}\nF.on(get, set)()\nobject.a\n/* => true */\nF.off(get, set)()\nobject.a\n/* => false */\nF.flip(get, set)()\nobject.a\n/* => true */\n",
  "value": "let state = {\n  a: 1\n}\nlet props = F.domLens.value('a', state)\nprops.value\n/* => 1 */\nprops.onChange({ target: { value: 5 } })\nstate.a\n/* => 5 */\n",
  "non-native value": "let state = {\n  a: 1\n}\nlet props = F.domLens.value('a', state)\nprops.value\n/* => 1 */\nprops.onChange(5)\nstate.a\n/* => 5 */\n",
  "checkboxValues": "let state = {\n  a: ['x', 'y', 'z']\n}\n// Props for if `x` is in the list\nlet props = F.domLens.checkboxValues('x', 'a', state)\nprops.checked\n/* => true */\n// uncheck\nprops.onChange({ target: { value: false } })\n_.includes('a', state.a)\n/* => false */\n",
  "hover": "let state = {\n  hovering: false\n}\nlet props = F.domLens.hover('hovering', state)\nprops.onMouseOver()\nstate.hovering\n/* => true */\nprops.onMouseOut()\nstate.hovering\n/* => false */\n",
  "focus": "let state = {\n  focusing: false\n}\nlet props = F.domLens.focus('focusing', state)\nprops.onFocus()\nstate.focusing\n/* => true */\nprops.onBlur()\nstate.focusing\n/* => false */\n",
  "targetBinding": "let state = {\n  flag: false\n}\nlet props = F.domLens.targetBinding('checked')('flag', state)\nprops.checked\n/* => false */\nprops.onChange({ target: { checked: true } })\nstate.flag\n/* => true */\n",
  "binding": "let state = {\n  selectedItem: 'item1'\n}\nlet weirdSelect = F.domLens.binding('selected', e => e.newSelectedValue)\nlet props = weirdSelect('selectedItem', state)\nprops.selected\n/* => 'item1' */\nprops.onChange({ newSelectedValue: 'newItem' })\nstate.selectedItem\n/* => 'newItem' */\n",
  "handle functions": "let clamp5 = f.ifElse(\n  x => x > 5,\n  () => 5,\n  x => x\n)\nclamp5(3)\n/* => 3 */\nclamp5(5)\n/* => 5 */\nclamp5(13)\n/* => 5 */\n",
  "handle passing boolean conditions": "let fn = f.ifElse(\n  true,\n  x => `success ${x}`,\n  x => `fail ${x}`\n)\nfn(1)\n/* => 'success 1' */\n",
  "handle fancy shorthand": "let fancyShortHand = f.ifElse({ a: 1 }, 'Has a1', () => 'No a1')\nfancyShortHand({ a: 1 })\n/* => 'Has a1' */\nfancyShortHand({ a: 2 })\n/* => 'No a1' */\n",
  "be fully curried": "f.ifElse(\n  x => x % 2,\n  x => `${x} is odd!`,\n  x => `${x} is even!`,\n  6\n)\n\n/* => '6 is even!' */\n",
  "when": "let clamp5 = f.when(\n  x => x > 5,\n  () => 5\n)\nclamp5(3)\n/* => 3 */\nclamp5(5)\n/* => 5 */\nclamp5(13)\n/* => 5 */\n",
  "unless": "let clamp5 = f.unless(\n  x => x < 5,\n  () => 5\n)\nclamp5(3)\n/* => 3 */\nclamp5(5)\n/* => 5 */\nclamp5(13)\n/* => 5 */\n",
  "whenExists": "let fn = f.whenExists(5)\nfn(3)\n/* => 5 */\nfn(null)\n/* => null */\nfn(false)\n/* => 5 */\n",
  "whenTruthy": "let fn = f.whenTruthy(5)\nfn(3)\n/* => 5 */\nfn(null)\n/* => null */\nfn(false)\n/* => false */\n",
  "maybeCall": "F.maybeCall(() => 5)\n/* => 5 */\nF.maybeCall(null)\n/* => false */\n",
  "maybeCall call fn with parameters": "const fn = (x, y) => x + y\nconst result = fn(5, 6)\nF.maybeCall(fn, 5, 6)\n/* => result */\n",
  "boundMethod bind a method of an object to it's object": "let obj = {\n  name: 'Wade Watts',\n  greet() {\n    return `Welcome, ${this.name}`\n  }\n}\nobj.greet.call({ name: 'John Henry' })\n/* => \n      'Welcome, John Henry'\n     */\nF.boundMethod('greet', obj)()\n/* => 'Welcome, Wade Watts' */\n",
  "comply": "// (5 * 2) +  5\nF.comply(F.append, x => x * 2)(5)\n/* => 15 */\n",
  "greaterThanOne": "for (let i = -10; i < 10; i++) {\n  F.greaterThanOne(i)\n  /* => i > 1 */\n}\n",
  "export the VERSION": "F.VERSION\n/* => global.__VERSION__ */\n",
  "singleObject": "F.singleObject('a', 'b')\n/* => {\n      a: 'b',\n    } */\n",
  "singleObjectR": "F.singleObjectR('a', 'b')\n/* => {\n      b: 'a',\n    } */\n",
  "chunkObject": "F.chunkObject([1])\n/* => [1] */\n\nF.chunkObject({\n  a: 1,\n  b: 2\n})\n\n/* => [\n      {\n        a: 1,\n      },\n      {\n        b: 2,\n      },\n    ] */\n",
  "compactObject": "F.compactObject({\n  a: 1,\n  b: null,\n  c: false\n})\n\n/* => {\n      a: 1,\n    } */\n",
  "isEmptyObject": "let expectEql = (obj, v) => F.isEmptyObject(obj)\n/* => v */\nexpectEql({ a: 1 }, false)\nexpectEql({}, true)\n",
  "isNotEmptyObject": "let expectEql = (obj, v) => F.isNotEmptyObject(obj)\n/* => v */\nexpectEql({ a: 1 }, true)\nexpectEql({}, false)\n",
  "stripEmptyObjects": "F.stripEmptyObjects({\n  a: 1,\n  b: {},\n  c: 2\n})\n\n/* => {\n      a: 1,\n      c: 2,\n    } */\n",
  "pickInto": "F.pickInto(\n  {\n    a: ['a'],\n    b: ['b'],\n    c: ['c']\n  },\n  { a: 1, b: 2 }\n)\n\n/* => {\n      a: { a: 1 },\n      b: { b: 2 },\n      c: {},\n    } */\n",
  "unwind": "F.unwind('x', {\n  x: ['a', 'b'],\n  y: 1\n})\n\n/* => [\n      {\n        x: 'a',\n        y: 1,\n      },\n      {\n        x: 'b',\n        y: 1,\n      },\n    ] */\n",
  "flattenObject": "F.flattenObject({\n  a: {\n    b: {\n      c: 1\n    }\n  }\n})\n\n/* => {\n      'a.b.c': 1,\n    } */\n\nF.flattenObject([\n  {\n    a: {\n      b: [\n        {\n          c: 1\n        }\n      ]\n    }\n  }\n])\n\n/* => {\n      '0.a.b.0.c': 1,\n    } */\n",
  "unflattenObject": "F.unflattenObject({\n  'a.b.c': 1\n})\n\n/* => {\n      a: {\n        b: {\n          c: 1,\n        },\n      },\n    } */\n",
  "renameProperty": "const o = { a: 1 }\nF.renameProperty('a', 'b', o)\n/* => o */\nF.renameProperty('a', 'b', o)\n/* => { b: 1 } */\nF.renameProperty('c', 'b', o)\n/* => { a: 1 } */\n",
  "matchesSignature": "F.matchesSignature([], 0)\n/* => false */\nF.matchesSignature([], '')\n/* => false */\nF.matchesSignature([], x => x)\n/* => true */\nF.matchesSignature([], [])\n/* => true */\nF.matchesSignature([], { a: 1 })\n/* => false */\nF.matchesSignature(['a'], { a: 1 })\n/* => true */\nF.matchesSignature(['b'], { a: 1 })\n/* => false */\nF.matchesSignature(['a'], { a: 1, b: 2 })\n/* => false */\nF.matchesSignature(['a'], { a: undefined, b: undefined })\n/* => \n      false\n     */\nF.matchesSignature(['a', 'b'], { a: undefined })\n/* => true */\n",
  "matchesSome": "F.matchesSome({ a: 1, b: 2 })({ a: 1, b: 2, c: 3 })\n/* => \n      true\n     */\nF.matchesSome({ a: 1, b: 20 })({ a: 1, b: 2, c: 3 })\n/* => \n      true\n     */\nF.matchesSome({ a: 10, b: 2 })({ a: 1, b: 2, c: 3 })\n/* => \n      true\n     */\nF.matchesSome({ a: 10, b: 20 })({ a: 1, b: 2, c: 3 })\n/* => \n      false\n     */\n",
  "compareDeep": "const o = { a: { b: { c: 1 } } }\nF.compareDeep('a.b.c', o, 1)\n/* => true */\nF.compareDeep('a.b.c', o, 2)\n/* => false */\nF.compareDeep('a.b.c')(o, '1')\n/* => false */\nF.compareDeep('a.b.c')(o)('1')\n/* => false */\n",
  "mapProp": "const a = F.mapProp('a', val => val * val, { a: 2, b: 1 })\na\n/* => { a: 4, b: 1 } */\n",
  "getOrReturn": "F.getOrReturn('x', { a: 1 })\n/* => { a: 1 } */\n",
  "alias": "F.alias('x', { a: 1 })\n/* => 'x' */\n",
  "aliasIn": "F.aliasIn({ a: 1 }, 'x')\n/* => 'x' */\n",
  "cascade": "F.cascade(['x', 'y'], { a: 1, y: 2 })\n/* => 2 */\nF.cascade(['x', 'c'], { a: 1, y: 2 }, 2)\n/* => 2 */\nF.cascade(['x', x => x.y], { a: 1, y: 2 })\n/* => 2 */\nF.cascade(['x', 'y'], { a: 1, x: null, y: 2 })\n/* => 2 */\n",
  "cascadeIn": "F.cascadeIn({ a: 1, y: 2 }, ['x', 'y'])\n/* => 2 */\n",
  "cascadeKey": "F.cascadeKey(['x', 'y'], { a: 1, x: 2 })\n/* => 'x' */\n",
  "cascadePropKey": "F.cascadePropKey(['x', 'y'], { a: 1, x: null, y: 2 })\n/* => \n      'x'\n     */\n",
  "cascadeProp": "F.cascadeProp(['x', 'y'], { a: 1, x: null, y: 2 })\n/* => \n      null\n     */\n",
  "unkeyBy": "F.unkeyBy('', {\n  a: {\n    x: 1\n  },\n  'd.e': {\n    x: 5\n  }\n})\n\n/* => [\n      {\n        x: 1,\n        a: 'a',\n      },\n      {\n        x: 5,\n        'd.e': 'd.e',\n      },\n    ] */\n",
  "simpleDiff": "F.simpleDiff(\n  {\n    x: 1,\n    a: 3,\n    d: {\n      f: 6\n    },\n    price: 20,\n    notChanged: 45\n  },\n  {\n    x: 1,\n    a: 1,\n    b: 2,\n    c: 3,\n    d: {\n      e: 5\n    },\n    price: undefined,\n    amount: 20\n  }\n)\n\n/* => {\n      a: {\n        from: 3,\n        to: 1,\n      },\n      b: {\n        from: undefined,\n        to: 2,\n      },\n      c: {\n        from: undefined,\n        to: 3,\n      },\n      'd.e': {\n        from: undefined,\n        to: 5,\n      },\n      amount: {\n        from: undefined,\n        to: 20,\n      },\n      price: {\n        from: 20,\n        to: undefined,\n      },\n    } */\n",
  "simpleDiffArray": "F.simpleDiffArray(\n  {\n    x: 1,\n    a: 3,\n    d: {\n      f: 6\n    },\n    price: 20,\n    notChanged: 45\n  },\n  {\n    a: 1,\n    b: 2,\n    c: 3,\n    x: 1,\n    d: {\n      e: 5\n    },\n    price: undefined,\n    amount: 20\n  }\n)\n\n/* => [\n      {\n        field: 'a',\n        from: 3,\n        to: 1,\n      },\n      {\n        field: 'b',\n        from: undefined,\n        to: 2,\n      },\n      {\n        field: 'c',\n        from: undefined,\n        to: 3,\n      },\n      {\n        field: 'd.e',\n        from: undefined,\n        to: 5,\n      },\n      {\n        field: 'price',\n        from: 20,\n        to: undefined,\n      },\n      {\n        field: 'amount',\n        from: undefined,\n        to: 20,\n      },\n    ] */\n",
  "diff": "F.diff(\n  {\n    x: 1,\n    a: 3,\n    d: {\n      f: 6\n    },\n    price: 20,\n    notChanged: 45\n  },\n  {\n    x: 1,\n    a: 1,\n    b: 2,\n    c: 3,\n    d: {\n      e: 5\n    },\n    price: undefined,\n    notChanged: 45,\n    amount: 20\n  }\n)\n\n/* => {\n      a: {\n        from: 3,\n        to: 1,\n      },\n      b: {\n        from: undefined,\n        to: 2,\n      },\n      c: {\n        from: undefined,\n        to: 3,\n      },\n      'd.e': {\n        from: undefined,\n        to: 5,\n      },\n      'd.f': {\n        from: 6,\n        to: undefined,\n      },\n      amount: {\n        from: undefined,\n        to: 20,\n      },\n      price: {\n        from: 20,\n        to: undefined,\n      },\n    } */\n",
  "diffArray": "F.diffArray(\n  {\n    z: {},\n    x: 1,\n    a: 3,\n    d: {\n      f: 6\n    },\n    price: 20,\n    notChanged: 45,\n    collection1: [{ a: 1, b: 2 }],\n    collection2: [{ a: 1, b: 2 }]\n  },\n  {\n    z: { zz: 1 },\n    a: 1,\n    b: 2,\n    c: 3,\n    x: 1,\n    d: {\n      e: 5\n    },\n    price: undefined,\n    amount: 20,\n    notChanged: 45,\n    collection1: [{ a: 1 }],\n    collection2: []\n  }\n)\n\n/* => [\n      {\n        field: 'a',\n        from: 3,\n        to: 1,\n      },\n      {\n        field: 'd.f',\n        from: 6,\n        to: undefined,\n      },\n      {\n        field: 'price',\n        from: 20,\n        to: undefined,\n      },\n      {\n        field: 'collection1.0.b',\n        from: 2,\n        to: undefined,\n      },\n      {\n        field: 'collection2.0.a',\n        from: 1,\n        to: undefined,\n      },\n      {\n        field: 'collection2.0.b',\n        from: 2,\n        to: undefined,\n      },\n      {\n        field: 'z.zz',\n        from: undefined,\n        to: 1,\n      },\n      {\n        field: 'b',\n        from: undefined,\n        to: 2,\n      },\n      {\n        field: 'c',\n        from: undefined,\n        to: 3,\n      },\n      {\n        field: 'd.e',\n        from: undefined,\n        to: 5,\n      },\n      {\n        field: 'amount',\n        from: undefined,\n        to: 20,\n      },\n    ] */\n",
  "mergeAllArrays": "F.mergeAllArrays([\n  {\n    a: 1,\n    b: [2, 3]\n  },\n  {\n    a: 3,\n    b: [4]\n  }\n])\n\n/* => {\n      a: 3,\n      b: [2, 3, 4],\n    } */\nF.mergeAllArrays([{ a: [1], b: 5 }, { a: [2] }])\n/* => {\n      a: [1, 2],\n      b: 5,\n    } */\n",
  "invertByArray": "F.invertByArray({\n  a: ['x', 'y', 'z'],\n  b: ['x']\n})\n\n/* => {\n      x: ['a', 'b'],\n      y: ['a'],\n      z: ['a'],\n    } */\n",
  "stampKey": "F.stampKey('type', {\n  foo: {\n    a: 1,\n    b: 2\n  },\n  bar: {}\n})\n\n/* => {\n      foo: {\n        a: 1,\n        b: 2,\n        type: 'foo',\n      },\n      bar: {\n        type: 'bar',\n      },\n    } */\n",
  "omitNil": "F.omitNil({ a: 1, b: 'c', d: null, e: undefined })\n/* => {\n      a: 1,\n      b: 'c',\n    } */\n",
  "omitNull": "F.omitNull({ a: 1, b: 'c', d: null, e: undefined })\n/* => {\n      a: 1,\n      b: 'c',\n      e: undefined,\n    } */\n",
  "omitBlank": "F.omitBlank({ a: 1, b: 'c', d: null, e: undefined, f: [], g: {}, h: '' })\n\n/* => {\n      a: 1,\n      b: 'c',\n    } */\n",
  "omitEmpty": "F.omitEmpty({ a: 1, b: 'c', d: null, e: undefined, f: [], g: {}, h: '' })\n\n/* => {\n      b: 'c',\n    } */\n",
  "mergeOverAll": "let foo = x => ({ [x]: 'foo' })\nlet bar = x => ({ bar: x, [x]: 'bar' })\nF.mergeOverAll([foo, bar])('a')\n/* => {\n      a: 'bar',\n      bar: 'a',\n    } */\nF.mergeOverAll([bar, foo])('a')\n/* => {\n      a: 'foo',\n      bar: 'a',\n    } */\n// should NOT merge arrays\nlet qux = a => ({ x: a.map(x => x + 3) })\nF.mergeOverAll([x => ({ x }), qux])([1, 2, 3])\n/* => {\n      x: [4, 5, 6],\n    } */\n// documenting edge case behavior\nF.mergeOverAll(undefined, undefined)\n/* => {} */\nF.mergeOverAll(undefined)(undefined)\n/* => {} */\nF.mergeOverAll([])(undefined)\n/* => undefined */\nF.mergeOverAll([x => x, (x, y) => y])('abc', 'de')\n/* => {\n      0: 'd',\n      1: 'e',\n      2: 'c',\n    } */\n",
  "mergeOverAllWith": "let reverseArrayCustomizer = (objValue, srcValue) =>\n  srcValue.length ? srcValue.reverse() : srcValue\nlet qux = a => ({ x: a.map(x => x + 3) })\n\nF.mergeOverAllWith(reverseArrayCustomizer, [() => ({}), qux])([1, 2, 3])\n\n/* => { x: [6, 5, 4] } */\n",
  "mergeOverAllArrays": "// should merge arrays\nlet qux = a => ({ x: a.map(x => x + 3) })\nF.mergeOverAllArrays([x => ({ x }), qux])([1, 2, 3])\n/* => {\n      x: [1, 2, 3, 4, 5, 6],\n    } */\n",
  "getWith": "let square = x => x * x\nlet getWithSquare = F.getWith(square)\nlet foo = { a: 1, b: 3, c: 5 }\ngetWithSquare('c', foo)\n/* => 25 */\nF.getWith(x => x + 1, 'b', foo)\n/* => 4 */\n// edge case: throws when customizer is not a function\nF.getWith(undefined, 'b', foo)\n/* => throws TypeError */\n",
  "expandObject": "let foo = { a: 1, b: 2, c: 'a' }\n// should expand object\nlet toOptions = F.mapIndexed((v, k) => ({ label: k, value: v }))\n\nF.expandObject(obj => ({ options: toOptions(obj) }), foo)\n\n/* => {\n      a: 1,\n      b: 2,\n      c: 'a',\n      options: [\n        { label: 'a', value: 1 },\n        { label: 'b', value: 2 },\n        { label: 'c', value: 'a' },\n      ],\n    } */\n// should override keys\nF.expandObject(_.invert, foo)\n/* => {\n      '1': 'a',\n      '2': 'b',\n      a: 'c',\n      b: 2,\n      c: 'a',\n    } */\n",
  "expandObjectBy": "let primeFactorization = x => (x === 42 ? { '2': 1, '3': 1, '7': 1 } : 'dunno')\nlet foo = { a: 1, b: 42 }\nF.expandObjectBy('b', primeFactorization, foo)\n/* => {\n      a: 1,\n      b: 42,\n      '2': 1,\n      '3': 1,\n      '7': 1,\n    } */\nF.expandObjectBy('a', primeFactorization, foo)\n/* => {\n      '0': 'd',\n      '1': 'u',\n      '2': 'n',\n      '3': 'n',\n      '4': 'o',\n      a: 1,\n      b: 42,\n    } */\n",
  "testRegex": "f.testRegex(/smart/i)('SmartProcure')\n/* => true */\nf.testRegex(/smart/)('SmartProcure')\n/* => false */\n",
  "makeRegExp": "const reText = 'Some text'\nconst options = 'gi'\nconst regExp = RegExp(reText, options)\n\nf.makeRegex(options)(reText)\n/* => regExp */\n",
  "makeAndTest": "const reText = 'Some text'\nconst options = 'gi'\nconst text = 'Here is some text to test'\nconst regex = RegExp(reText, options)\nconst result = regex.test(text)\n\nf.makeAndTest(options)(reText)(text)\n/* => result */\n",
  "matchAnyWord": "const reText = 'Some text'\nconst text = 'Here is some text to test'\nconst match = f.matchAnyWord(reText)\n\nmatch(text)\n/* => true */\n",
  "matchAllWords": "const reText = 'Some text'\nconst text = 'Here is some to test'\nconst match = f.matchAllWords(reText)\n\nmatch(text)\n/* => false */\n",
  "return all matched results": "const re = '(\\\\d+)'\nconst text = `1 22 333 a bb ccc 4444`\nconst matches = f.allMatches(re, text)\nmatches\n/* => [\n      { text: '1', start: 0, end: 1 },\n      { text: '22', start: 2, end: 4 },\n      { text: '333', start: 5, end: 8 },\n      { text: '4444', start: 18, end: 22 },\n    ] */\n",
  "get postings": "var result = f.postings(RegExp('p', 'gi'), 'pretty please')\nresult\n/* => [\n      [0, 1],\n      [7, 8],\n    ] */\n",
  "get postings by word": "var result = f.postingsForWords('pret pr t ', 'pretty prease')\nresult\n/* => [\n      [[0, 4]],\n      [\n        [0, 2],\n        [7, 9],\n      ],\n      [\n        [3, 4],\n        [4, 5],\n      ],\n    ] */\n",
  "highlight": "let input = 'pretty please'\nlet postings = f.postings(RegExp('p', 'gi'), input)\nlet expected =\n  '<span class=\"highlight\">p</span>retty <span class=\"highlight\">p</span>lease'\nf.highlightFromPostings(start, end, postings, input)\n/* => \n      expected\n     */\n",
  "highlight backwards postings": "let input = 'pretty please'\nlet expected =\n  '<span class=\"highlight\">p</span>retty <span class=\"highlight\">p</span>lease'\n\nf.highlightFromPostings(\n  start,\n  end,\n  [\n    [7, 8],\n    [0, 1]\n  ],\n  input\n)\n\n/* => expected */\n",
  "high level highlight": "let input = 'pretty please'\nlet pattern = 'pr pl'\nlet expected =\n  '<span class=\"highlight\">pr</span>etty <span class=\"highlight\">pl</span>ease'\nf.highlight(start, end, pattern, input)\n/* => expected */\n",
  "wrap": "let wrapped = '(asdf)'\nF.wrap('(', ')', 'asdf')\n/* => wrapped */\nF.wrap(null, null, 'asdf')\n/* => 'asdf' */\n",
  "quote": "F.quote('asdf')\n/* => '\"asdf\"' */\n",
  "parens": "let wrapped = '(asdf)'\nF.parens('asdf')\n/* => wrapped */\n",
  "concatStrings": "F.concatStrings(['This ', '  is a  ', null, '', 'sentence!'])\n\n/* => 'This is a sentence!' */\n",
  "trimStrings": "F.trimStrings(['This ', '  is a  ', null, '', 'sentence!'])\n\n/* => ['This', 'is a', null, '', 'sentence!'] */\n\nF.trimStrings({ a: 'a', b: ' b ', c: 'c ', d: ' d', e: 5 })\n\n/* => { a: 'a', b: 'b', c: 'c', d: 'd', e: 5 } */\n",
  "autoLabel": "F.autoLabel('whatDoYouThinkOfThisHTML5Stuff? IThinkItIsREALLYCool')\n\n/* => \n      'What Do You Think Of This HTML 5 Stuff I Think It Is REALLY Cool'\n     */\nF.autoLabel('thisIsAVariable')\n/* => 'This Is A Variable' */\n\nF.autoLabel('thisIs_startCaseWithACRONYMSAndNumbersLike123and4')\n\n/* => 'This Is Start Case With ACRONYMS And Numbers Like 123 And 4' */\n// Passive aggressive example of how to better auto generate PR titles from branch names...\nF.autoLabel('Feature/AutoLabel#126')\n/* => \n      'Feature Auto Label 126'\n     */\n",
  "autoLabelOption": "F.autoLabelOption('someValue')\n/* => {\n      value: 'someValue',\n      label: 'Some Value',\n    } */\n",
  "autoLabelOptions": "F.autoLabelOptions([\n  { value: '', label: 'Empty String Value' },\n  'someValue',\n  { value: 'justAValue' },\n  { value: 'bothValueAndLabel', label: 'Custom Label' }\n])\n\n/* => [\n      { value: '', label: 'Empty String Value' },\n      { value: 'someValue', label: 'Some Value' },\n      { value: 'justAValue', label: 'Just A Value' },\n      { value: 'bothValueAndLabel', label: 'Custom Label' },\n    ] */\n",
  "toSentenceWith": "F.toSentenceWith(' - ', ' or ', ['first', 'second', 'third'])\n\n/* => 'first - second or third' */\n",
  "toSentence": "F.toSentence(['first', 'second', 'third'])\n/* => \n      'first, second and third'\n     */\n",
  "uniqueString": "let dedupe = F.uniqueString([])\ndedupe.cache\n/* => {} */\n\n_.map(\n  dedupe,\n  _.times(() => 'foo', 5)\n)\n\n/* => ['foo', 'foo1', 'foo2', 'foo3', 'foo4'] */\ndedupe.cache\n/* => {\n      foo: 5,\n      foo1: 1,\n      foo2: 1,\n      foo3: 1,\n      foo4: 1,\n    } */\nF.uniqueString(_.keys(dedupe.cache))('foo')\n/* => 'foo5' */\n// should cache result strings to avoid conflicts with user-specified strings that\n// would have matched a uniqueString result\nlet badFoos = ['foo', 'foo1', 'foo', 'foo2', 'foo', 'foo3', 'foo']\n_.map(F.uniqueString([]), badFoos)\n/* => [\n      'foo',\n      'foo1',\n      'foo2',\n      'foo21',\n      'foo3',\n      'foo31',\n      'foo4',\n    ] */\nlet text = _.words(`\n      Creates a function that invokes func with the arguments of the created function. If\n      func is a property name, the created function returns the property value for a given\n      element. If func is an array or object, the created function returns true for elements\n      that contain the equivalent source properties, otherwise it returns false.\n    `)\n_.size(_.uniq(text))\n/* => text.length */\nlet uniqueText = _.map(F.uniqueString(), text)\n_.size(_.uniq(uniqueText))\n/* => uniqueText.length */\n// clearing should work\ndedupe.clear()\ndedupe.cache\n/* => {} */\n// should handle calling with no arguments\nF.uniqueString(null)('test')\n/* => is a 'string' */\nF.uniqueString(undefined)('test')\n/* => is a 'string' */\nF.uniqueString()('test')\n/* => is a 'string' */\n",
  "uniqueStringWith": "let a = ['foo20', 'foo21', 'foo23', 'foo24', 'foo25']\nlet stripDigits = F.arrayToObject(_.replace(/(\\d+)$/, ''), () => 1)\nlet uniqueStringStripDigits = F.uniqueStringWith(stripDigits, a)\nuniqueStringStripDigits.cache\n/* => { foo: 1 } */\nuniqueStringStripDigits('foo')\n/* => 'foo1' */\n// Should work with appending other stuff if you really want to\nlet appendHiForSomeReason = F.arrayToObject(_.identity, () => 'hi')\n\n_.map(F.uniqueStringWith(appendHiForSomeReason, ['foo']), ['foo', 'foo', 'bar'])\n\n/* => ['foohi', 'foohi1', 'bar'] */\n",
  "isTraversable": "F.isTraversable([])\n/* => true */\nF.isTraversable({})\n/* => true */\nF.isTraversable('')\n/* => false */\nF.isTraversable(5)\n/* => false */\n",
  "traverse": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nF.traverse(x)\n/* => x */\n",
  "pre-order traversal": "F.walk()(tree => {\n  values.push(tree)\n})(x)\nvalues\n/* => [x, x.a, x.b, x.b.c] */\n",
  "post-order traversal": "let values = []\nF.walk()(\n  () => {},\n  tree => {\n    values.push(tree)\n  }\n)(x)\nvalues\n/* => [x.a, x.b.c, x.b, x] */\n",
  "halting": "let values = []\nlet r = F.walk()(tree => {\n  values.push(tree)\n  return _.isNumber(tree)\n})(x)\nvalues\n/* => [x, x.a] */\nr\n/* => x.a */\n",
  "halting with tree return": "let values = []\nlet r = F.walk()(\n  () => {},\n  (tree, i, [parent]) => {\n    values.push(tree)\n    if (!parent) return tree\n  }\n)(x)\nvalues\n/* => [x.a, x.b.c, x.b, x] */\nr\n/* => x */\n",
  "retain parent stack and indices": "let values = []\nF.walk()((x, i, parents) => {\n  values.push([x, parents, i])\n})(x)\nvalues\n/* => [\n        [x, [], undefined],\n        [x.a, [x], 'a'],\n        [x.b, [x], 'b'],\n        [x.b.c, [x.b, x], 'c'],\n      ] */\n",
  "reduceTree": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nF.reduceTree()((r, i) => F.push(i, r), [], x)\n/* => [\n      x,\n      x.a,\n      x.b,\n      x.b.c,\n    ] */\n",
  "treeToArray": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nF.treeToArray()(x)\n/* => [x, x.a, x.b, x.b.c] */\n",
  "treeToArrayBy": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\n\nF.treeToArrayBy()(i => (_.isNumber(i) ? i * 2 : i), x)\n\n/* => [x, x.a * 2, x.b, x.b.c * 2] */\n",
  "leaves": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nF.leaves()(x)\n/* => [1, 2] */\n",
  "tree": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nlet tree = F.tree()\ntree.toArray(x)\n/* => [x, x.a, x.b, x.b.c] */\n",
  "lookup": "let x = {\n  a: 1,\n  items: [\n    {\n      a: 2,\n      items: [\n        {\n          a: 3\n        },\n        {\n          a: 4,\n          b: 4\n        }\n      ]\n    },\n    {\n      a: 5\n    }\n  ]\n}\nlet tree = F.tree(x => x.items)\n\ntree.lookup([{ a: 2 }, { a: 4 }], x)\n/* => \n      x.items[0].items[1]\n     */\n",
  "lookup with path": "let x = {\n  a: '1',\n  items: [\n    {\n      a: '2',\n      items: [\n        {\n          a: '3'\n        },\n        {\n          a: '4',\n          b: 4\n        }\n      ]\n    },\n    {\n      a: '5'\n    }\n  ]\n}\nlet tree = F.tree(\n  x => x.items,\n  a => ({ a })\n)\ntree.lookup(['2', '4'], x)\n/* => x.items[0].items[1] */\n",
  "transform": "let x = {\n  a: '1',\n  items: [\n    {\n      a: '2',\n      items: [\n        {\n          a: '3'\n        },\n        {\n          a: '4',\n          b: 4\n        }\n      ]\n    },\n    {\n      a: '5'\n    }\n  ]\n}\n\nF.transformTree(x => x.items)(x => {\n  x.b = 'transformed'\n}, x)\n\n/* => {\n      a: '1',\n      b: 'transformed',\n      items: [\n        {\n          a: '2',\n          b: 'transformed',\n          items: [\n            {\n              a: '3',\n              b: 'transformed',\n            },\n            {\n              a: '4',\n              b: 'transformed',\n            },\n          ],\n        },\n        {\n          a: '5',\n          b: 'transformed',\n        },\n      ],\n    } */\nx\n/* => {\n      a: '1',\n      items: [\n        {\n          a: '2',\n          items: [\n            {\n              a: '3',\n            },\n            {\n              a: '4',\n              b: 4,\n            },\n          ],\n        },\n        {\n          a: '5',\n        },\n      ],\n    } */\n",
  "keyByWith": "let x = {\n  a: 'first',\n  items: [\n    {\n      a: 'second',\n      items: [\n        {\n          a: 'first'\n        },\n        {\n          a: 'second',\n          b: 4\n        },\n        {\n          a: 'second',\n          b: 6\n        }\n      ]\n    },\n    {\n      a: 'second'\n    }\n  ]\n}\nlet tree = F.tree(x => x.items)\n\ntree.keyByWith(\n  (x, matches, group) => {\n    if (matches) x.type = `${group} type`\n  },\n  'a',\n  x\n)\n\n/* => {\n      first: {\n        a: 'first',\n        type: 'first type',\n        items: [\n          {\n            a: 'second',\n            items: [\n              {\n                a: 'first',\n                type: 'first type',\n              },\n              {\n                a: 'second',\n                b: 4,\n              },\n              {\n                a: 'second',\n                b: 6,\n              },\n            ],\n          },\n          {\n            a: 'second',\n          },\n        ],\n      },\n      second: {\n        a: 'first',\n        items: [\n          {\n            a: 'second',\n            type: 'second type',\n            items: [\n              {\n                a: 'first',\n              },\n              {\n                a: 'second',\n                type: 'second type',\n                b: 4,\n              },\n              {\n                a: 'second',\n                type: 'second type',\n                b: 6,\n              },\n            ],\n          },\n          {\n            a: 'second',\n            type: 'second type',\n          },\n        ],\n      },\n    } */\n",
  "flattenTree": "let properties = {\n  Field1: {\n    type: 'text'\n  },\n  Field2: {\n    properties: {\n      Field2A: {\n        properties: {\n          Field2A1: {\n            type: 'text'\n          },\n          Field2A2: {\n            type: 'text'\n          },\n          Field2A3: {\n            properties: {\n              Field2A3a: {\n                type: 'text'\n              }\n            }\n          }\n        }\n      },\n      Field2B: {\n        type: 'text'\n      },\n      Field2C: {\n        type: 'text'\n      }\n    }\n  }\n}\nlet Tree = F.tree(x => x.properties)\nlet result = _.flow(Tree.flatten(), _.omitBy(Tree.traverse))({ properties })\nresult\n/* => {\n      Field1: {\n        type: 'text',\n      },\n      'Field2.Field2A.Field2A1': {\n        type: 'text',\n      },\n      'Field2.Field2A.Field2A2': {\n        type: 'text',\n      },\n      'Field2.Field2A.Field2A3.Field2A3a': {\n        type: 'text',\n      },\n      'Field2.Field2B': {\n        type: 'text',\n      },\n      'Field2.Field2C': {\n        type: 'text',\n      },\n    } */\n",
  "flattenTree with propTreePath": "let Tree = F.tree(x => x.children)\nlet result = Tree.flatten(F.propTreePath('key'))({\n  key: 'root',\n  children: [\n    {\n      key: 'criteria',\n      children: [\n        {\n          key: 'filter'\n        }\n      ]\n    },\n    {\n      key: 'analysis',\n      children: [\n        {\n          key: 'results'\n        }\n      ]\n    }\n  ]\n})\nresult\n/* => {\n      root: {\n        key: 'root',\n        children: [\n          {\n            key: 'criteria',\n            children: [\n              {\n                key: 'filter',\n              },\n            ],\n          },\n          {\n            key: 'analysis',\n            children: [\n              {\n                key: 'results',\n              },\n            ],\n          },\n        ],\n      },\n      'root/analysis': {\n        key: 'analysis',\n        children: [\n          {\n            key: 'results',\n          },\n        ],\n      },\n      'root/analysis/results': {\n        key: 'results',\n      },\n      'root/criteria': {\n        key: 'criteria',\n        children: [\n          {\n            key: 'filter',\n          },\n        ],\n      },\n      'root/criteria/filter': {\n        key: 'filter',\n      },\n    } */\nTree.flatLeaves(result)\n/* => [\n      {\n        key: 'filter',\n      },\n      {\n        key: 'results',\n      },\n    ] */\n"
}